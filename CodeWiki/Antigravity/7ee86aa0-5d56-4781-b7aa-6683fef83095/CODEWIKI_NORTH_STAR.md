# CodeWiki North Star: The "Code Intelligence Platform" Vision

Your 4-point proposal is excellent. It effectively upgrades CodeWiki from a "Documentation Generator" to a **"Code Intelligence Platform"**.

This document translates your requirements into a concrete technical architecture.

---

## 1. Dual-View Architecture (User vs. Developer)
**Goal:** Serve two distinct audiences from the same data source.

*   **The "User" View (Product Documentation)**
    *   **Source:** `Level 1` (Module/Class Structure) + `LLM` (Summarization).
    *   **Focus:** "What does this do?" (Capability).
    *   **Technique:** Use CGR to find public APIs (`Function` nodes where `is_public=True`). Feed *only* these signatures + docstrings to the LLM to generate "Usage Guides".
    *   **Abstraction:** High. Hides implementation details.

*   **The "Developer" View (Technical Reference)**
    *   **Source:** `Level 2` (Joern Data Flow) + `Git Metadata` + `Structural Graph`.
    *   **Focus:** "How does this work?" (Implementation).
    *   **Technique:** Display raw graph relationships directly. Show "Callers", "Callees", "Database Writes", and "Exception Paths".
    *   **Abstraction:** None. Full transparency.

---

## 2. Deterministic "Tool-First" Output
**Goal:** Remove LLM hallucination for critical facts.

*   **Shift in Philosophy:** The LLM should never be asked to *discover* facts, only to *explain* them.
*   **The "Agent Replacement" Strategy:**
    *   *Current (Agent):* "Read code, find potential bugs." (Unreliable)
    *   *New (Tool-Driven):* "Run Joern query `cpg.call.name('exec').l`, export results." (Deterministic)
*   **Implementation:**
    *   Build a library of **"Static Queries"** (e.g., "Find all recursive calls", "Find circular dependencies").
    *   These queries run during the build phase. The results are stored as JSON/Graph properties.
    *   The frontend displays these findings as "Insights" or "Alerts" without needing an LLM at runtime.

---

## 3. & 4. The "Time Dimension" (Git Integration)
**Goal:** Track evolution, history, and "Why" (Intent).

**Architectural Risk:**
Storing *every* line of git history in a Graph Database will cause data explosion. A repo with 10k commits and 1k files = 10M potential edge variations.

**The "Hybrid Storage" Solution:**
Do not replicate Git. **Link to Git.**

*   **The Graph (Metadata Layer):**
    *   Nodes: `Commit`, `Author`, `PullRequest`.
    *   Edges: `(Function)-[:MODIFIED_BY]->(Commit)`.
    *   Properties: `commit_msg`, `date`, `churn_score` (how often this function changes).
*   **The Git Repo (Content Layer):**
    *   Use `git` CLI or `libgit2` to fetch the actual *diff content* on demand.

**What this Enables (The "No-LLM" Frontend):**

Only by linking Graph + Git, you can answer complex questions **deterministically** in the UI:

1.  **"Who owns this code?"**
    *   *Query:* `MATCH (f:Function {name: 'processPayment'})-[:MODIFIED_BY]->(c:Commit)<-[:AUTHORED]-(u:User) RETURN u.name, count(c) ORDER BY count(c) DESC`
    *   *Result:* "Alice (45 commits), Bob (2 commits)". (No LLM needed).

2.  **"Why was this logic added?"**
    *   *Query:* `MATCH (f:Function)-[:MODIFIED_BY]->(c:Commit) RETURN c.message, c.date`
    *   *Result:* A timeline of intent. "Fix NPE in edge case (2024-01-01)" -> "Add support for Stripe (2024-02-15)".

3.  **"Is this code stable?"**
    *   *Query:* Calculate `churn_score` based on edge count to `Commit` nodes in the last 30 days.
    *   *Result:* "High Volatility (Changed 15 times this month) - Risk Factor: High".

---

## 5. The Ultimate UI Vision
**"Information without Hallucination"**

Imagine a CodeWiki frontend where clicking a function `processOrder` shows:

1.  **Header:** Function Signature & Docstring (from Level 1).
2.  **Left Panel (User):** "Usage Examples" (Generated by LLM *once*, cached).
3.  **Right Panel (Dev - Deterministic):**
    *   **Flow:** "Calls: `validateUser`, `chargeCard`". (from Level 2).
    *   **Data:** "Writes to: `OrdersTable`". (from Level 2).
    *   **History:** "Last Change: 2 days ago by Alice ('Fix double charge bug')". (from Git Link).
    *   **Impact:** "Used by: `CheckoutAPI`, `AdminPortal`". (from Level 1).

**Conclusion:**
This is technically feasible. The key is to **stop treating code as text** (for LLMs to read) and **start treating code as data** (for Graph + Git to query). The LLM moves from being the "Processor" to being the "Narrator".
